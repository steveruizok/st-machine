{"moduleFile":{"sourceFilePath":"/Users/stephenruiz/GitHub/st-machine/src/st-machine/index.tsx","localImports":[],"externalImports":[],"potentialCmpRefs":[],"hasSlot":false,"hasSvg":false,"jsFilePath":"/Users/stephenruiz/GitHub/st-machine/src/st-machine/index.js"},"jsText":"// TODO:\r\n// substate history\r\n// State Machine\r\nexport default class StateMachine {\r\n    // @constructor\r\n    // Store stateMap states and set the machine's initial point in history.\r\n    constructor(stateMap, onChange) {\r\n        this.subscribers = [];\r\n        this.history = [];\r\n        this.hIndex = 0;\r\n        this.changeTime = new Date();\r\n        // ---------------\r\n        // Public Methods\r\n        // ---------------\r\n        // @method subscribe\r\n        // Add an object to this StateMachine's subscribers.\r\n        //\r\n        // @param subscriber: any - The subscriber object.\r\n        // @param prop: string - The property to set when notifying this subscriber.\r\n        this.subscribe = (subscriber, prop = \"mState\") => {\r\n            if (this.subscribers.includes(subscriber)) {\r\n                throw \"Attempted to subscribe an existing subscriber.\";\r\n            }\r\n            const mSubscriber = {\r\n                ref: subscriber,\r\n                prop: prop\r\n            };\r\n            this.subscribers = [...this.subscribers, mSubscriber];\r\n            mSubscriber.ref[prop] = this.current;\r\n        };\r\n        // @method unsubscribe\r\n        // Remove an object from this StateMachine's subscribers.\r\n        //\r\n        // @param subscriber: any - The subscriber object.\r\n        this.unsubscribe = (subscriber) => {\r\n            if (!this.subscribers.includes(subscriber)) {\r\n                throw \"Attempted to unsubscribe a non-subscriber.\";\r\n            }\r\n            this.subscribers = this.subscribers.filter(s => s.ref !== subscriber);\r\n        };\r\n        // @method dispatch\r\n        // Handle an dispatched action from a subscriber, finding a valid transition in\r\n        // the current path's state tree, and ignoring dispatches for actions\r\n        // that aren't found in the current path's state tree.\r\n        //\r\n        // @param action: string - The name of the action.\r\n        // @param payload: any - The data attached to the dispatch.\r\n        this.dispatch = (action, payload) => {\r\n            const stateTree = this.current.path.slice().reverse();\r\n            let foundTransition;\r\n            for (let state of stateTree) {\r\n                let result = state.transitions.find(t => t.action === action);\r\n                if (!result) {\r\n                    continue;\r\n                }\r\n                foundTransition = result;\r\n                break;\r\n            }\r\n            // Ignore dispatches for actions that aren't included\r\n            // in the current state's transitions.\r\n            if (!foundTransition) {\r\n                return;\r\n            }\r\n            this.setState(foundTransition, payload);\r\n        };\r\n        // @method willRespondTo\r\n        // Returns true if the machine's current state will respond to any of one or more actions.\r\n        //\r\n        // @param actionNames: string|string[] - The action name(s) to check.\r\n        this.willRespondTo = (actionNames) => {\r\n            if (!Array.isArray(actionNames)) {\r\n                actionNames = [actionNames];\r\n            }\r\n            let validActions = this.getValidActions();\r\n            for (let actionName of actionNames) {\r\n                if (validActions.includes(actionName)) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        // @method wontRespondTo\r\n        // Returns false if the machine's current state will respond to any of one or more actions.\r\n        //\r\n        // @param actionNames: string|string[] - The action name(s) to check.\r\n        this.wontRespondTo = (actionNames) => {\r\n            if (!Array.isArray(actionNames)) {\r\n                actionNames = [actionNames];\r\n            }\r\n            let validActions = this.getValidActions();\r\n            for (let actionName of actionNames) {\r\n                if (validActions.includes(actionName)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        };\r\n        // @method isnt\r\n        // Returns false if the machine's current state name is any of one or more values.\r\n        //\r\n        // @param stateNames: string|string[] - The state name(s) to check.\r\n        this.isnt = (stateNames) => {\r\n            if (!Array.isArray(stateNames)) {\r\n                stateNames = [stateNames];\r\n            }\r\n            for (let stateName of stateNames) {\r\n                if (this.current.name === stateName) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        };\r\n        // @method is\r\n        // Returns true if the machine's current state name is any of one or more values.\r\n        //\r\n        // @param stateNames: string|string[] - The state name(s) to check.\r\n        this.is = (stateNames) => {\r\n            if (!Array.isArray(stateNames)) {\r\n                stateNames = [stateNames];\r\n            }\r\n            for (let stateName of stateNames) {\r\n                if (this.current.name === stateName) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        // @method Undo\r\n        // Go back one step in the Machine's history.\r\n        this.undo = () => {\r\n            this.goToHistoryIndex(-1);\r\n        };\r\n        // @method Redo\r\n        // Go forward one step in the Machine's history.\r\n        this.redo = () => {\r\n            this.goToHistoryIndex(1);\r\n        };\r\n        // --------------\r\n        // Private Methods\r\n        // --------------\r\n        // @method getValidActions\r\n        // Return an array of the actions that the current state will respond to.\r\n        this.getValidActions = () => {\r\n            let validActions = [];\r\n            this.current.path.forEach(state => {\r\n                state.transitions.forEach(t => {\r\n                    validActions = [...validActions, t.action];\r\n                });\r\n            });\r\n            return validActions;\r\n        };\r\n        // @method goToHistoryIndex\r\n        // Move to a history state, without mutating history.\r\n        //\r\n        // @param change: number - The relative number of steps to move forward or backward.\r\n        this.goToHistoryIndex = (change) => {\r\n            let newIndex = this.hIndex + change;\r\n            if (newIndex < 0) {\r\n                newIndex = 0;\r\n            }\r\n            else {\r\n                if (newIndex > this.history.length - 1) {\r\n                    newIndex = this.history.length - 1;\r\n                }\r\n            }\r\n            if (newIndex === this.hIndex) {\r\n                return;\r\n            }\r\n            this.changeTime = new Date();\r\n            this.hIndex = newIndex;\r\n            this.notifySubscribers();\r\n        };\r\n        // @method getState\r\n        // Locate a state, given the state's name.\r\n        //\r\n        // @param stateName: string - The name of the state.\r\n        this.getState = (stateName) => {\r\n            let root;\r\n            let foundState;\r\n            const stateTree = this.current.path.slice().reverse();\r\n            // At each state in the state tree, look for a state named stateName.\r\n            for (let state of stateTree) {\r\n                if (!state.states) {\r\n                    continue;\r\n                }\r\n                let found = state.states.find(s => s.name === stateName);\r\n                if (!found) {\r\n                    continue;\r\n                }\r\n                foundState = found;\r\n                break;\r\n            }\r\n            // If we couldn't find a state in the stateTree, search again\r\n            // at the root level.\r\n            if (!foundState) {\r\n                root = true;\r\n                foundState = this.states.find(s => s.name === stateName);\r\n            }\r\n            // And if we still haven't found one, throw an error, because\r\n            // that state doesn't exist anywhere in the tree.\r\n            if (!foundState) {\r\n                throw new Error(\"Could not find a state with that name.\");\r\n            }\r\n            // If the new state has states of its own, change to the initial\r\n            // state -- or, if not specified, to the first state in the\r\n            // states array.\r\n            if (foundState.states && !root) {\r\n                foundState = foundState.initial\r\n                    ? foundState.states.find(s => s.name === foundState.initial)\r\n                    : foundState.states[0];\r\n            }\r\n            return foundState;\r\n        };\r\n        // @method setState\r\n        // Set a new state, based on the dispatched transition.\r\n        //\r\n        // @param transition: MTransition - The action/response dispatched.\r\n        // @param payload: any - The data attached to the dispatch.\r\n        this.setState = (transition, payload) => {\r\n            if (transition.response.includes(\".\")) {\r\n                let stateTree = transition.response.split(\".\");\r\n                console.log(stateTree);\r\n                let state = this;\r\n                let i = 0;\r\n                while (i < stateTree.length) {\r\n                    path = path.states.find(s => s.name === stateTree[i]);\r\n                    i++;\r\n                }\r\n                const nextState = path;\r\n            }\r\n            else {\r\n                const nextState = this.getState(transition.response);\r\n            }\r\n            const newDate = new Date();\r\n            this.history[this.hIndex].duration =\r\n                newDate.getTime() - this.changeTime.getTime();\r\n            this.changeTime = new Date();\r\n            this.hIndex++;\r\n            this.history = [\r\n                ...this.history.slice(0, this.hIndex),\r\n                {\r\n                    state: nextState,\r\n                    payload: payload,\r\n                    date: newDate,\r\n                    duration: 0\r\n                }\r\n            ];\r\n            this.notifySubscribers();\r\n        };\r\n        // @method notifySubscribers\r\n        // Alert all subscribers that the machine's state has changed.\r\n        this.notifySubscribers = () => {\r\n            this.subscribers.forEach(subscriber => {\r\n                subscriber.ref[subscriber.prop] = this.current;\r\n            });\r\n            if (this.onChange) {\r\n                this.onChange(this.history[this.hIndex]);\r\n            }\r\n        };\r\n        // Store the onChange callback.\r\n        this.onChange = onChange;\r\n        // Create a path (a state tree) for each state\r\n        function setPath(state, path) {\r\n            state.path = path;\r\n            if (!state.states) {\r\n                return;\r\n            }\r\n            state.states.forEach(s => {\r\n                setPath(s, [...path, s]);\r\n            });\r\n        }\r\n        stateMap.states.forEach(s => {\r\n            setPath(s, [s]);\r\n        });\r\n        // store stateMap's pathed states as own states property\r\n        this.states = stateMap.states;\r\n        // get our initial state\r\n        const initial = stateMap.initial\r\n            ? this.states.find(s => s.name === stateMap.initial)\r\n            : this.states[0];\r\n        if (!initial) {\r\n            throw new Error(`Could not find a state with that name (${stateMap.initial}`);\r\n        }\r\n        // start the history array\r\n        this.history = [\r\n            ...this.history,\r\n            {\r\n                state: initial,\r\n                payload: stateMap.payload,\r\n                date: this.changeTime,\r\n                duration: 0\r\n            }\r\n        ];\r\n        if (this.onChange) {\r\n            this.onChange(this.history[this.hIndex]);\r\n        }\r\n    }\r\n    // @getter current\r\n    // Get the machine's current state name.\r\n    get current() {\r\n        let current = this.history[this.hIndex];\r\n        if (!current) {\r\n            return null;\r\n        }\r\n        return Object.assign({}, current, { name: current.state.name, path: current.state.path });\r\n    }\r\n    // @getter current\r\n    // Get the machine's current state name.\r\n    get historyIndex() {\r\n        return this.historyIndex;\r\n    }\r\n}\r\n"}